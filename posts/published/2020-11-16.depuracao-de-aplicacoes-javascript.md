---
path: /depuracao-de-aplicacoes-javascript

title: Depura√ß√£o de aplica√ß√µes JavaScript
subtitle: Como ir al√©m do console.log e encontrar erros de forma mais eficiente
date: 2020-11-16
tags:
  - dev
  - js

banner:
  author: The Nigmatic
  href: https://unsplash.com/photos/ssMYmNDdPtI
  image: ./images/2020-11-16.depuracao-de-aplicacoes-javascript/banner.jpg
---

Se voc√™ j√° escreveu algum trecho de c√≥digo e percebeu que algo n√£o funcionava como deveria, com certeza voc√™ j√° depurou uma aplica√ß√£o.

Tamb√©m conhecido como `debugging` (ou `debugar`), `depurar` √© essa etapa de desenvolvimento onde voc√™, atrav√©s de ferramentas e funcionalidades da linguagem ou do seu editor/IDE, come√ßa um processo de investigar e encontrar algum erro (ou `bug`) ou comportamento n√£o desejado em seu software.

Particularmente acredito que quanto eficiente voc√™ for com as ferramentas de depura√ß√£o que pode utilizar, mais facilmente voc√™ vai achar algum problema e investigar algo necess√°rio em sua aplica√ß√£o. O que faz com que voc√™ economize muito tempo e tamb√©m evite ficar batendo cabe√ßa sem necessidade.

O intuito desse post √© compilar algumas dicas e utilit√°rios que eu gosto de utilizar no meu dia-a-dia e que percebi que me tornam mais produtivo.

### _debugger_, _breakpoints_ e os _sourcemaps_
Provavelmente o t√≥pico que mais mudou a forma como eu realizo esse processo de _debugging_ nas aplica√ß√µes que eu encontro por a√≠.

A palavra chave `debugger;` √© uma instru√ß√£o que faz com que nosso c√≥digo seja "pausado" (ou, em outras palavras, √© um _breakpoint_) em um momento qualquer de execu√ß√£o. Podemos colocar

Vamos fazer um teste. Rode o seguinte c√≥digo com o DevTools aberto:
```js
function a() {
  var numero = 1;
  b();
}

function b() {
  var numero = 2;
  c();
}

function c() {
  var numero = 3;
  debugger;
}

a();
```

Assim que executar, voc√™ perceber√° que o c√≥digo ser√° executado e seu `DevTools` pausar√° no momento em que encontra a declara√ß√£o `debugger;`. Com isso, voc√™ consegue ter acesso √†s vari√°veis dispon√≠veis nesse momento em que o _breakpoint_ est√° ativo.

Com isso voc√™ tamb√©m consegue clicar em alguma outra linha, criando outro _breakpoint_ diretamente pelo `DevTools`, facilitando muito o trabalho de validar suas fun√ß√µes e vari√°veis em um determinado ponto no seu c√≥digo.

Nesse momento de pausa voc√™ consegue visualizar alguns bot√µes que permitem que voc√™ continue a execu√ß√£o da sua aplica√ß√£o e at√© mesmo navegue entre linhas ou execu√ß√µes de fun√ß√µes caso seja necess√°rio.

Para aplica√ß√µes que utilizam NodeJS, n√£o basta apenas colocar uma instru√ß√£o `debugger;`. Voc√™ tamb√©m precisar√° executar a aplica√ß√£o informando os argumentos `--inspect` ou `--inspect-brk`. Isso iniciar√° um processo que estar√° atrelado ao seu `DevTools` (preferencialmente o Google Chrome) de maneira que, ap√≥s execut√°-lo, voc√™ ver√° o √≠cone do NodeJS.

A diferen√ßa entre `--inspect` e `--inspect-brk` √© que o primeiro apenas inicia o processo atrelado ao navegador. J√° o segundo, cria um _breakpoint_ pra voc√™ automaticamente na primeira linha do seu c√≥digo, caso voc√™ n√£o tenha nenhuma instru√ß√£o `debugger;` escrita ou queira navegar pelos arquivos do seu projeto antes.

Caso isso n√£o ocorra, mesmo ap√≥s executar o Node com esses valores, voc√™ pode dar uma olhada nas suas configura√ß√µes do Google Chrome (na url [chrome://inspect](chrome://inspect)) e checar se as op√ß√µes necess√°rias est√£o ativas.

#### SourceMaps
No entanto, apenas utilizar _debugger_ ou _breakpoints_ pode n√£o ajudar muito quando voc√™ lida com c√≥digo comprimido/minificado, o que √© muito comum.

Para isso existem os sourcemaps, aqueles arquivos com extens√£o `.map` que podem ser gerados por ferramentas de build. Esses arquivos guardam referencias aos arquivos fontes de projetos que utilizam ferramentas que trabalham com essas compress√µes/minifica√ß√µes ou qualquer outro processo de compila√ß√£o (como TypeScript).

Eles servem para que, mesmo ap√≥s processar algum c√≥digo fonte, voc√™ consiga depurar o conte√∫do escrito sem lidar com o c√≥digo alterado (antes de process√°-lo), manipulando atrav√©s de breakpoints e "visualizando" diretamente o c√≥digo que voc√™ escreveu.

Por exemplo, o seguinte c√≥digo em TypeScript:
```ts
// arquivo index.ts
function test(a: number, b: number) {
  debugger;
  return a + b;
}

test(1, 2);
```

Ir√° gerar o conte√∫do abaixo, ap√≥s ser compilado:
```js
// arquivo dist/index.js
"use strict";
function test(a, b) {
    debugger;
    return a + b;
}
test(1, 2);
//# sourceMappingURL=index.js.map
```

Note que no fim do conte√∫do, existe um coment√°rio com `sourceMappingURL` apontando para um arquivo `index.js.map`. Esse arquivo √© um `json` contendo o seguinte:
```json
{
  "version":3,
  "file":"index.js",
  "sourceRoot":"",
  "sources":["../src/index.ts"],
  "names":[],
  "mappings":";AAAA,SAAS,IAAI,CAAC,CAAS,EAAE,CAAS;IAC9B,QAAQ,CAAC;IACT,OAAO,CAAC,GAAG,CAAC,CAAC;AACjB,CAAC;AAED,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC,CAAA"
}
```

E nesse conte√∫do temos algumas informa√ß√µes importantes, como:
- a vers√£o (`version`) do _sourcemap_;
- o arquivo (`file`) compilado que est√° relacionado ao _sourcemap_ (`index.js`);
- os arquivos fonte (`sources`) que geraram o _sourcemap_;
- uma sequ√™ncia de mapeamentos (`mappings`), que servem como base para a rela√ß√£o entre o c√≥digo fonte e o c√≥digo compilado.

Esses mapeamentos s√£o gerados utilizando Base64 VLQ que √© uma forma de codificar algum conte√∫do, mas podemos ter em mente que s√£o dados que relacionam o c√≥digo compilado do arquivo `file` com o c√≥digo fonte em `sources`.

Se quiser ler um pouco mais sobre Base64 VLQ e como esses mapeamentos s√£o gerados, voc√™ pode ver esses 3 outros posts (em ingl√™s):
- [How do source maps work?, por Matt Zeunert](https://www.mattzeunert.com/2016/02/14/how-do-source-maps-work.html);
- [Introduction to JavaScript Source Maps, por Ryan Seddon](https://ryanseddon.com/javascript/source-mapping/);
- [Decoding and Encoding Base64 VLQs in Source Maps, por Ty Lewis](https://www.lucidchart.com/techblog/2019/08/22/decode-encoding-base64-vlqs-source-maps/).


Com essas refer√™ncias e o arquivo _sourcemap_ gerado corretamente, mesmo utilizado o _debugger_ na aplica√ß√£o, √© poss√≠vel ver pelo `DevTools` o c√≥digo TypeScript que foi escrito e n√£o o JavaScript que foi gerado apos a compila√ß√£o.

Ah, vale comentar que esses arquivos de sourcemap s√≥ s√£o baixados no dispositivo caso o `DevTools` esteja aberto, evitando o consumo desnecess√°rio de recursos. O mesmo se aplica para c√≥digos CSS que s√£o processados por algum pr√©-processador ou algo do tipo.

### Fun√ß√µes do Console
O console √©, de longe, um dos amigos mais antigos de quem escreve c√≥digos em JavaScript e voc√™ provavelmente j√° o deve conhecer.

#### log
A fun√ß√£o mais conhecida de todas. Basta passar alguma mensagem ou vari√°vel para ele, que aparecer√° no seu console:
```js
const mensagem = 'Texto do console';

console.log(mensagem); // exibe 'Texto do console';
```

Dessa forma, sua mensagem √© exibida corretamente.

##### Logs formatados
O primeiro passo que podemos dar al√©m do console tradicional, √© formatar alguns logs conforme nossa necessidade. Voc√™ pode formatar visualmente um log adicionando o prefixo `%c` antes de sua mensagem e passando como segundo argumento do console uma string com regras de CSS.

Mais ou menos dessa forma:
```js
const css = 'background: tomato; color: white;';
const mensagem = 'Texto do console';

console.log(`%c${mensagem}`, css); // exibe 'Texto do console';
```

Com isso, sua mensagem aparecer√° igual anteriormente, mas com as regras de CSS aplicadas. Rode esse exemplo no console do seu navegador e veja o resultado.

No caso de aplica√ß√µes com NodeJS, para mostrar seu log formatado as op√ß√µes s√£o um pouco diferentes. Voc√™ precisa informar os c√≥digos das cores usando padr√£o ANSI.

Por exemplo, `\x1b[32m` deixa um texto verde. Ap√≥s isso, precisamos concatenar `%s` para escrever nossa string e depois `\x1b[0m` que √© o c√≥digo que redefine as cores de log (para que os logs seguintes da aplica√ß√£o n√£o tenham o mesmo estilo aplicado). Tendo, ao final, algo como:
```js
const cor = '\x1b[32m';
const texto = '%s';
const reset = '\x1b[0m';
const definicoes = `${cor}${texto}${reset}`;

const mensagem = 'Texto do console';

console.log(definicoes, mensagem);
```

Com isso, o texto ficar√° verde.

#### error, info e debug
S√£o outros tr√™s n√≠veis de erro diferente. No caso do `info` a mensagem aparece com algumas marca√ß√µes de informa√ß√£o diferente no navegador. `error` j√° exibe uma mensagem como se fosse um erro da aplica√ß√£o (mas disparado pelo console) e `debug`
```js
console.log('info');
console.error('error');
console.debug('debug');
```


#### dir
Uma forma de exibir valores de forma mais organizada e com uma lista interativa. Por exemplo:
```js
const pessoa = {
  nome: 'gabriel'
};

console.dir(pessoa);
```

Com isso, o objeto ser√° exibido mas com uma formata√ß√£o de lista e voc√™ pode clicar para expandir os valores internos.

#### table
Exibe uma tabela com os valores do array/objeto informado:
```js
const pessoa = {
  nome: 'gabriel'
};

console.table(pessoa);
```

### Algumas ferramentas mais voltadas √† verifica√ß√£o de performance
Existem alguns utilit√°rios do console que servem para medir o tempo de execu√ß√£o de um trecho de c√≥digo. Claro que, como todo c√≥digo JavaScript, esses valores mudaram de ambiente pra ambiente, dependendo bastante do processamento de cada m√°quina que executa um mesmo c√≥digo.

#### time, timeLog e timeEnd
S√£o tr√™s fun√ß√µes utilizadas para criar um contador e verificar quanto tempo um trecho de c√≥digo √© utilizado. Todas elas (`time`, `timeLog` e `timeEnd`) levam necessitam de um texto que √© utilizado como marcador desse contador criado. E elas funcionam da seguinte maneira:

- `time`: inicia um contador com o marcador selecionado;
- `timeLog`: exibe um log de algum marcador;
- `timeEnd`: finaliza algum marcador criado.

Vamos fazer um exemplo para ficar mais claro. Vamos criar um timer com marcador `loop`, rodar um `for` 10 vezes e, ap√≥s isso, finaliz√°-lo:
```js
const marcador = 'loop';
console.time(marcador);

for(let i = 0; i < 10; i++) {
  console.timeLog(marcador, `rodou o la√ßo no indice ${i}`);
}

console.timeEnd(marcador, 'finalizou loop');
```

Ao executar esse c√≥digo, criamos um `time` com o marcador `loop` e temos algumas mensagens. Sendo elas:
- 10 para a execu√ß√£o do la√ßo;
- 1 para a finaliza√ß√£o do marcador `time`.

Cada uma delas com seu respectivo tempo de execu√ß√£o ao lado.

#### performance API
Tamb√©m dispon√≠vel como um [objeto global](https://developer.mozilla.org/pt-BR/docs/Web/API/Window/performance) para ser verificado, `performance` √© uma [API](https://developer.mozilla.org/pt-BR/docs/Web/API/Performance) que pode ser utilizada para verificar algumas informa√ß√µes como os valores de mem√≥ria (`memory`), que apresenta informa√ß√µes sobre espa√ßo de mem√≥ria alocado e que pode ser utilizado em sua aplica√ß√£o.

### copy
Um utilit√°rio para quando voc√™ precisa copiar alguma estrutura para a √°rea de transfer√™ncia com o `DevTools` aberto que pouca gente usa.

Basta executar, no `DevTools`, algo como:
```js
const estrutura = {
  pessoa: {
    nome: 'gabriel'
  }
};

copy(estrutura);
```

Que o objeto da vari√°vel `estrutura` estar√° na sua √°rea de transfer√™ncia. √â bem pr√°tico e ajuda muito na hora de copiar alguma vari√°vel e jogar em um editor de texto para ver seus valores. Ajuda ainda mais quando voc√™ tem alguma resposta muito grande de uma requisi√ß√£o e precisa validar algum √∫nico campos.

### Boas investiga√ß√µes üîé
Espero que algum desses utilit√°rios ou estrat√©gias possa te ajudar a investigar e encontrar algum problema de forma mais eficiente. Quem sabe at√© mesmo a estudar alguma aplica√ß√£o nova por a√≠!
