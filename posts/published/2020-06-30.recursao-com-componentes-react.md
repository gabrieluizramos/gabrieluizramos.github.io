---
path: /recursao-com-componentes-react

title: Recurs√£o com componentes React
subtitle: Como utilizar recursividade para renderizar uma √°rvore de componentes pode deixar seu trabalho mais simples e enxuto
date: 2020-06-30
tags:
  - dev
  - react
banner:
  author: ùì¥ùìòùì°ùìö ùïùùî∏ùïÄ
  href: https://unsplash.com/photos/BtzBvzbTYxo
  image: ./images/2020-06-30.recursao-com-componentes-react/banner.jpg
---

Nem sempre alguns conceitos te√≥ricos sobre computa√ß√£o s√£o aplic√°veis ou comuns no dia-a-dia, principalmente quando voc√™ desenvolve front-end. Quando o assunto √© **recursividade**, isso n√£o √© diferente.

### T√°, mas pra que eu vou precisar usar isso?
Al√©m de ser uma √≥tima forma de aplicar efetivamente um conceito te√≥rico, tamb√©m √© uma forma um pouco mais enxuta (por√©m nem sempre a mais perform√°tica) de resolver algum problema, como esse aqui:

> Imagine que voc√™ precisa renderizar uma √°rvore de componentes onde cada elemento pode ou n√£o ter in√∫meros filhos

Um pouco abstrato demais, eu sei, mas para deixar as coisas mais interessantes, vamos imaginar que para uma lista de itens como essa (onde as chaves dos objetos s√£o os nomes dos links e os valores s√£o as URLs finais):
```js
[
  { "Link 1": "/link-1" },
  { "Link 2": "/link-2" },
  {
    "Sublist 1": [
      { "Sublink 1": "/sublink-1" },
      { "Sublink 2": "/sublink-2" },
      {
        "Another sublist": [
          { "Sublink 1": "/sublink-1" },
          { "Sublink 2": "/sublink-2" }
        ]
      }
    ]
  },
  { "Link 3": "/link-3" },
  {
    "Link 4": [
      { "Sublink 1": "/sublink-1" },
      { "Sublink 2": "/sublink-2" },
      { "Sublink 3": "/sublink-3" }
    ]
  }
];
```

Voc√™ quer renderizar algo como:
```html
<dl>
   <dd><a href="/link-1">Link 1</a></dd>
   <dd><a href="/link-2">Link 2</a></dd>
   <dd>
      <dl>
         <dt>Sublist 1</dt>
         <dd><a href="/sublink-1">Sublink 1</a></dd>
         <dd><a href="/sublink-2">Sublink 2</a></dd>
         <dd>
            <dl>
               <dt>Another sublist</dt>
               <dd><a href="/sublink-1">Sublink 1</a></dd>
               <dd><a href="/sublink-2">Sublink 2</a></dd>
            </dl>
         </dd>
      </dl>
   </dd>
   <dd><a href="/link-3">Link 3</a></dd>
   <dd>
      <dl>
         <dt>Link 4</dt>
         <dd><a href="/sublink-1">Sublink 1</a></dd>
         <dd><a href="/sublink-2">Sublink 2</a></dd>
         <dd><a href="/sublink-3">Sublink 3</a></dd>
      </dl>
   </dd>
</dl>
```

Ou seja, cada item da lista pode ter ou n√£o, outras diversas sub-listas e assim por diante.

### E o que √© recurs√£o?
**Recurs√£o** (ou **recursividade**) √© uma estrat√©gia para resolver um problema, de forma repetitiva e iterativa, envolvendo uma fun√ß√£o que chama a si mesma (com algum caso final que envolve a finaliza√ß√£o da recurs√£o).

√â meio estranho olhando pela primeira vez, eu sei, n√£o √© a toa que existe uma frase que diz:

> Para entender recurs√£o, voc√™ primeiro precisa entender recurs√£o

Os exemplos mais cl√°ssicos de recurs√£o na internet envolvem, geralmente, alguns exemplos matem√°ticos como `fibonacci` ou `fatorial`.

Para n√£o nos prender tanto em qualquer um desses exemplos, vamos criar uma fun√ß√£o que recebe um n√∫mero e faz um contador (com `console.log`) contando at√© `0`, a partir desse n√∫mero;

Utilizando la√ßos de repeti√ß√£o, essa fun√ß√£o ficaria mais ou menos assim:

```js
// criamos a fun√ß√£o contador
const contador = total => {
  // rodamos um la√ßo de repeti√ß√£o com uma vari√°vel de controle
  // que vai sendo decrementada e logando o contador
  for(let numero = total; numero >= 0; numero--) {
    console.log(`Contador: ${numero}`);
  }
};

contador(10);
// Contador: 10
// ...
// Contador: 0
```

E, ao utilizar recurs√£o, teremos uma fun√ß√£o mais ou menos assim:
```js
// criamos a fun√ß√£o contador
const contador = total => {
  // verificamos nossa condi√ß√£o de parada
  // para n√£o ca√≠rmos em um loop infinito
  if (total >= 0) {
    // enquanto o total for >= 0, continuamos executando
    console.log(`Contador: ${total}`);
    // e por fim, chamamos a pr√≥pria fun√ß√£o contador
    return contador(total - 1);
  } else {
    // condi√ß√£o de parada
    // caso contador seja igual a zero
    // encerramos a execu√ß√£o
    return;
  }
};

contador(10);
// Contador: 10
// ...
// Contador: 0
```

Recursividade por si s√≥ √© um t√≥pico extenso e nem sempre √© a forma mais perform√°tica de resolver um problema iterativo, dependendo muito da linguagem que voc√™ utiliza. Para nosso exemplo, vai cair como uma luva.

---

### Aplicando isso ao nosso exemplo

Como no nosso exemplo, o array √© composto por objetos onde, cada objeto, possui a estrutura:
```js
[
  { 'Titulo do link': 'url' }
]
```

Podemos iniciar nosso racioc√≠nio utilizando a fun√ß√£o `Object.entries`, que nos retornar√° um array de arrays, contendo as chaves e os valores dos nossos objetos. Ou seja, para um objeto como:
```js
  { 'Titulo do link': 'url' }
```

Temos a seguinte sa√≠da:
```js
const objeto = { 'Titulo do link': 'url' };
const entries = Object.entries(objeto)

console.log(entries);
/*
  [
    ['Titulo do link', 'url']
  ]
*/
```
E, ao ter um objeto mais complexo (com v√°rios links da sublista dentro):
```js
const objeto = { 'Titulo do link': [
  { 'sublink 1': 'url 1' },
  { 'sublink 2': 'url 2' },
] };
const entries = Object.entries(objeto)

console.log(entries);
/*
  [
    ['Titulo do link',
      [
        { 'sublink 1': 'url 1' },
        { 'sublink 2': 'url 2' }
      ]
    ]
  ]
*/
```

Analisando essas estruturas (que s√£o, basicamente, as estruturas das nossas listas) j√° podemos ter em mente como iremos resolver esse problema:
- Iremos fazer um `map` na lista de exemplo (para gerarmos componentes a partir dela);
- Para cada item da lista, iremos verificar suas chaves e valores (com `Object.entries`);
- Se os valores de cada um desses itens, forem arrays, iremos renderizar a chave como t√≠tulo e continuar renderizando a lista recursivamente;
- Caso os valores n√£o sejam arrays, renderizamos o item final da lista com o link.

Bora l√°!

### Fun√ß√£o recursiva e componente principal
Como iremos rodar um `map` em nosso array, vamos criar de forma separada a fun√ß√£o que ser√° executada nesse `map` para cada item do array:

```jsx
const renderiza = item => {};
```

Podemos importar nossa estrutura de links e executar essa fun√ß√£o dentro de um componente, da seguinte forma:
```jsx
// imaginando que nossa estrutura com os links est√° no arquivo links.js
import links from './links';

const renderiza = item => {};

const Lista = () => <dl>{links.map(renderiza)}</dl>
```

Como nossa lista tamb√©m possuir√° t√≠tulos, sem√¢nticamente, os elementos `<dl>` (para lista), `<dt>` (para o t√≠tulo) e `<dd>` (para os itens) s√£o os mais adequados (acredito eu). Ent√£o vamos criar esses dois componentes.

Agora, vamos come√ßar a implementar as condi√ß√µes que colocamos acima, validando as entradas (chave e valor) de cada um dos objetos:
```jsx
const renderiza = item => {
  const valores = Object.entries(item);
}
```

Como `Object.entries` nos retorna um array de arrays, podemos fazer um `map` nele tamb√©m:
```jsx
const renderiza = item => {
  const valores = Object.entries(item);
  return Object.entries(item).map((entradas) =>
    // proximo passo
  );
}
```

Agora precisamos verificar, se esses itens dentro do `map` (que possuem o t√≠tulo e os links) possuem arrays na segunda posi√ß√£o do array (lembrando que a primeira √© a chave do objeto e a segunda √© o valor dessa chave).
```jsx
const renderiza = item => {
  const valores = Object.entries(item);
  // podemos fazes desestrutura√ß√£o das entradas do objeto para "title" e "link"
  return valores.map(([title, link]) =>
    // verificamos se "link" √© um array
    Array.isArray(link) ? (
      // se for array, renderizaremos uma lista
    ) : (
      // se n√£o for, renderizaremos o item final
    )
  );
}
```

### Sub componentes

O pr√≥ximo passo √© criar os componentes de item e lista. Podemos imaginar que o componente `SubList` receber√° um `title` e um `items` com prop e renderizar√° uma lista com um t√≠tulo:
```jsx
const SubLista = ({ title, items }) => (
  <dl>
    <dt>{title}</dt>
  </dl>
);
```

E o componente de item de lista, receber√° somente um `title` e um `link`:
```jsx
const Item = ({ title, link }) => (
  <dd>
    <a href={link}>{title}</a>
  </dd>
);
```

Agora, podemos renderizar esses dois componentes na fun√ß√£o `renderiza` que criamos mais acima:
```jsx
const renderiza = item => {
  const valores = Object.entries(item);
  return valores.map(([title, link]) =>
    Array.isArray(link) ? (
      // agora renderizamos a sublista
      // passando o titulo e a lista de itens
      <SubLista title={title} items={link} />
    ) : (
      // e renderizamos o item final
      <Item title={title} link={link} />
    )
  );
};
```

Para finalizarmos, basta chamarmos a fun√ß√£o `renderiza` dentro do nosso componente de sublista. Dessa forma, esse componente tamb√©m mapear√° cada um dos itens renderizando eles com a pr√≥pria fun√ß√£o que ele foi renderizado!

Para fazer isso, √© s√≥ atualizar o componente de `SubLista` realizando um `map` nos itens, tamb√©m usando a fun√ß√£o `renderiza`, da seguinte forma:
```jsx
const SubLista = ({ title, items }) => (
  <dl>
    <dt>{title}</dt>
    {items.map(renderiza)}
  </dl>
);
```

### E nosso c√≥digo final...
Ao fim de todo esse processo, teremos um c√≥digo mais ou menos assim:

```jsx
import links from './links';

const SubLista = ({ title, items }) => (
  <dl>
    <dt>{title}</dt>
    {items.map(renderiza)}
  </dl>
);

const Item = ({ title, link }) => (
  <dd>
    <a href={link}>{title}</a>
  </dd>
);

const renderiza = item => {
  const valores = Object.entries(item);
  return valores.map(([title, link]) =>
    Array.isArray(link) ? (
      <SubLista title={title} items={link} />
    ) : (
      <Item title={title} link={link} />
    )
  );
};

const Lista = () => <dl>{links.map(renderiza)}</dl>
```

Agora voc√™ pode isolar os seus componentes nos arquivos que achar melhor e estiliz√°-los como for necess√°rio.

---

### Demo

Se voc√™ quiser ver o resultado final, deixei um exemplo pronto no [CodeSandbox](https://codesandbox.io/s/recursive-rendering-react-components-ksmyb). Se preferir, pode brincar direto com a demo abaixo:

<iframe
     src="https://codesandbox.io/embed/recursive-rendering-react-components-ksmyb?fontsize=14&hidenavigation=1&theme=dark"
     style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;"
     title="Recursive rendering React components"
     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
     sandbox="allow-autoplay allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
   ></iframe>


---

### Mas... U√©???

A primeira vista √© algo meio estranho e um pouco fora da maneira como estamos acostumados a resolver problemas de interface, mas tenho certeza que √© um conceito que pode te ajudar algum dia.

Embora o exemplo n√£o seja exatamente igual ao contador que criamos no come√ßo, podemos perceber que a estrutura √© a mesma.

Mesmo com a abstra√ß√£o dos componentes em `React`, utilizamos uma fun√ß√£o `renderiza` que verifica se ainda temos uma lista de links para renderizar e, internamente, dentro de cada uma dessas listas, chamamos essa mesma fun√ß√£o `renderiza`, at√© que s√≥ sejam renderizados os itens finais com os links.

Bem mais enxuto do que utilizar la√ßos de repeti√ß√£o, n√£o acha?
