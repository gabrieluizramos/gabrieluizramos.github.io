---
path: /anatomia-de-um-teste-em-javascript

title: Anatomia de um teste em JavaScript
subtitle: Como funcionam testes comportamentais e que estruturas as ferramentas utilizam para otimizar sua escrita e manutenÃ§Ã£o
date: 2020-05-25
tags:
  - dev
  - tests

banner:
  author: Nino Liverani
  href: https://unsplash.com/photos/CKxD_Qh6ULY
  image: ./images/2020-05-25.anatomia-de-um-teste-em-javascript/banner.jpg
---

Se vocÃª trabalha utilizando ou jÃ¡ leu algo sobre testes, talvez jÃ¡ tenha se deparado com algumas estruturas, termos e nomenclaturas que podem causar algumas confusÃµes.

Ã‰ comum tentar assemelhar seus testes Ã  maneira que seu software Ã© utilizado pelos seus usuÃ¡rios. Isso Ã© uma parte muito importante do [processo de confianÃ§a](/voce-confia-em-si/) que vocÃª cria com o cÃ³digo que vocÃª desenvolve. Um pouco na linha de pensamento utilizada no `BDD` (*Behavior Driven Development* ou Desenvolvimento Guiado a Comportamento), embora seja um tÃ³pico um pouco mais abrangente.

Entender como funciona a anatomia de um teste, sabendo os pedaÃ§os envolvidos no processo e como seu teste Ã© avaliado Ã© parte importante nesse processo todo.

Para prosseguirmos com alguns exemplos de cÃ³digo, seguirei algumas estruturas propostas por frameworks pelo [Jest](https://jestjs.io/), acredito que Ã© uma das ferramentas que tem mais visibilidade hoje em dia. Mas existem outras no mercado que possuem estruturas semelhantes e, os fundamentos, podem ser aproveitados da mesma maneira.

### Cobertura (ou *coverage*)
Ã‰ um dos termos mais comuns e acho que Ã© o que mais utilizamos como parÃ¢metro para algumas decisÃµes e resultados quando estamos escrevendo testes.

A **cobertura** de testes indica quais partes de seu cÃ³digo estÃ£o sendo **executadas**. Por exemplo: se temos um cÃ³digo de `10 linhas` e uma **cobertura** de `50%`, isso quer dizer que apenas metade das linhas desse cÃ³digo (ou seja, `5 linhas`) estÃ£o sendo executadas ao longo dos testes.

Algumas ferramentas geram alguns relatÃ³rios visuais em HTML ou atÃ© mesmo diretamente no seu terminal, como Ã© o caso do `Jest`, que oferece um report com uma tabela parecida com essa:

```
----------|----------|----------|----------|----------|-------------------|
File      |  % Stmts | % Branch |  % Funcs |  % Lines | Uncovered Line #s |
----------|----------|----------|----------|----------|-------------------|
All files |      100 |      100 |      100 |      100 |                   |
 data.js  |      100 |      100 |      100 |      100 |                   |
----------|----------|----------|----------|----------|-------------------|
```

Vale a pena darmos uma passada sobre cada uma das categorias desse relatÃ³rio de cobertura.

- Arquivo (ou *`file`*): nessa coluna podemos ver todos os arquivos que foram executados ao longo dos testes escritos;
- DeclaraÃ§Ãµes (ou *statements/stmts*): indica quais os termos de declaraÃ§Ã£o (como variÃ¡veis e *`imports`*) foram ou nÃ£o cobertos ao executar os testes;
- RamificaÃ§Ãµes (ou *`branch`*): analisando a palavra *`branch`* temos `ramo` (ou "galho") como traduÃ§Ã£o em portuguÃªs o que faz com que essa coluna possa ser confundida com as *`branches`* do git, entÃ£o vale ressaltar que sÃ£o coisas diferentes. Os valores que aparecem nessa coluna nÃ£o condizem com a cobertura de sua *`branch`* do git, mas sim com as ramificaÃ§Ãµes de seu cÃ³digo. Podemos entender como ramificaÃ§Ã£o qualquer trecho de cÃ³digo que divide a execuÃ§Ã£o de nosso programas em duas ou mais partes, ou seja: trechos com blocos *`if/else`*, *`switch/case`* ou `ternÃ¡rios`; O que essa coluna relata Ã© justamente essa questÃ£o: quantas ramificaÃ§Ãµes (trechos de execuÃ§Ãµes distintas) do cÃ³digo escrito nos arquivos foram executadas.
- FunÃ§Ãµes (ou *`functions/funcs`*): indica se as funÃ§Ãµes (rotinas e sub-rotinas) do seu cÃ³digo foram executadas ao longo dos seus testes;
- Linhas (ou *`lines`*): indica quantas linhas do cÃ³digo estÃ£o cobertas;
- Linhas nÃ£o cobertas (ou `uncovered lines`): ao contrÃ¡rio do item anterior, indica quais linhas `nÃ£o` foram cobertas nos testes.

Agora vamos ver alguns trechos e exemplos mais prÃ¡ticos e entender como eles funcionam.

### SuÃ­tes de teste (ou test suites)
SuÃ­tes de teste Ã© um termo utilizado pra exemplificar um agrupamento de testes. Basicamente! :)

Ã‰ comum que, no caso do `Jest`, isso seja confundido com os blocos de `describe`, que sÃ£o usados para agrupar alguns testes dentro de um mesmo arquivo, mas [**nÃ£o Ã© o caso**](https://jestjs.io/docs/en/api.html#describename-fn). Pode parecer confuso, mas o `Jest` considera que cada arquivo Ã© uma suite de teste diferente.

Nesse caso, a utilizaÃ§Ã£o do `describe` Ã© exclusivamente para realizar um agrupamento mais especÃ­fico de testes relacionados, por exemplo:

```js
describe('Calculadora', () => {
  // testes relacionados aos cÃ¡lculos
});
```

Essa estrutura Ã© totalmente opcional, jÃ¡ que Ã© possÃ­vel criar testes utilizando outras funÃ§Ãµes que veremos a seguir. Entretanto, Ã© uma boa ferramenta para aprimorar a semÃ¢ntica (ou seja, o significado) de seus testes jÃ¡ que agrupa testes (ou outros `describe`) com uma `descriÃ§Ã£o`.

### O teste em si
Ã‰ o bloco onde devem ser declarados os testes que realmente serÃ£o executados e onde as asserÃ§Ãµes (que veremos a seguir) serÃ£o inseridas.

AtravÃ©s do `Jest` podem ser acessados atravÃ©s das funÃ§Ãµes `it` (que nada mais Ã© que um apelido, ou `alias` para as funÃ§Ãµes `test`).

Dessa forma, podemos criar alguns testes como:

```js
describe('Calculadora', () => {
  it('Soma', () => {

  });
  // ou com test
  test('Soma', () => {

  });
});
```

Como `it` e `test` sÃ£o iguais, vocÃª pode optar pelo que achar melhor.

O que vale a pena ter em mente Ã© que, assim como o `describe`, utilizar um ou outro pode trazer alguns detalhes mais semÃ¢nticos pro seu cÃ³digo, jÃ¡ que as funÃ§Ãµes tem nomenclaturas diferentes.

### AsserÃ§Ãµes (ou assertions)
AsserÃ§Ã£o significa afirmaÃ§Ã£o. Ã‰ com as asserÃ§Ãµes que iremos afirmar o comportamento esperado do nosso cÃ³digo. Assim como os blocos de `describe` e `it`, sÃ£o funÃ§Ãµes que possuem uma nomenclatura semÃ¢ntica. Podemos pensar na utilizaÃ§Ã£o das asserÃ§Ãµes em duas partes:
- valor atual (ou de entrada/esperado);
- valor a ser comparado (ou de saÃ­da/resultado).

Com base nesses dois valores, conseguimos sempre organizar nossos testes. Vamos voltar ao exemplo da calculadora e vamos tentar implementar o teste da funÃ§Ã£o de soma (nÃ£o vamos realizar a funÃ§Ã£o em si).

Podemos criar nosso bloco de descriÃ§Ã£o (`describe`) com um teste (`it`) para iniciar:

```js
import calculadora from './calculadora';

describe('Calculadora', () => {
  it('Soma', () => {
    // faremos o teste aqui
  });
});
```

Vamos imaginar que teremos um objeto `calculadora` que possui o mÃ©todo `soma`, que recebe como parÃ¢metro dois valores que serÃ£o somados. Dessa forma, acessamos a funÃ§Ã£o utilizando `calculadora.soma`.

Com isso, podemos jÃ¡ criar algumas variÃ¡veis que serÃ£o responsÃ¡veis por conter nosso valor `esperado` e nosso `resultado`.

Continuando o teste:

```js
import calculadora from './calculadora';

describe('Calculadora', () => {
  it('Soma', () => {
    // atual (a ser testado)
    const atual = calculadora.soma(1, 1);
    // resultado esperado
    const resultado = 2;

    // asserÃ§Ã£o serÃ¡ feita a seguir
  });
});
```

JÃ¡ temos as variÃ¡veis com o retorno funÃ§Ã£o (`atual`) e o resultado esperado (`resultado`).

Com isso podemos escrever nossa asserÃ§Ã£o. A funÃ§Ã£o Ã© iniciada com `expect` (pois iremos consultar e `esperar` que algum valor seja igual a algo que determinamos) e essa funÃ§Ã£o retorna um objeto com outras funÃ§Ãµes (chamadas `matchers` onde verificamos valores correspondentes), como: `toEqual` (verifica se um valor Ã© igual a outro), `toThrow` (verifica se um erro foi disparado), `toBeGreaterThan` (verifica se o valor Ã© maior que outro).

Caso tenha precise, vocÃª tambÃ©m pode criar seus [`matchers`](https://jestjs.io/docs/pt-BR/expect#expectextendmatchers) customizados.

Nesse exemplo, podemos utilizar o `toEqual` jÃ¡ que vamos comparar se o valor retornado por nossa funÃ§Ã£o Ã© igual a `2`.

```js
import calculadora from './calculadora';

describe('Calculadora', () => {
  it('Soma', () => {
    // atual (a ser testado)
    const atual = calculadora.soma(1, 1);
    // resultado esperado
    const resultado = 2;

    // asserÃ§Ã£o feita
    expect(atual).toEqual(esperado);
  });
});
```

PoderÃ­amos ter moldado o teste de qualquer forma, inclusive removendo as variÃ¡veis e passando os valores diretamente. Mas acho que dividindo os testes nessas etapas (entrada, saÃ­da e execuÃ§Ã£o da funÃ§Ã£o) Ã© uma forma prÃ¡tica de entender como tudo funciona.

Sobre a semÃ¢ntica e a leitura dos testes que comentamos, podemos parar para fazer uma leitura sobre o teste que criamos. Ao ler o cÃ³digo desenvolvido, podemos ler algo como:

```
DescriÃ§Ã£o: calculadora
Ela: soma
Espero: que o valor atual (2) seja igual ao esperado (resultado da calculadora.soma(1, 1));
```

Com isso, conseguimos ver que alÃ©m de nos trazer mais confianÃ§a, escrever testes que se assemelham Ã  forma como seu software Ã© utilizado Ã© uma forma tambÃ©m de documentar seu sistema. Se seus testes estÃ£o organizados, vocÃª consegue executÃ¡-los, ler suas descriÃ§Ãµes e entender como seu sistema funciona.

### Hooks
Outra estrutura que as ferramentas (como o `Jest`) costumam disponibilizar, sÃ£o funÃ§Ãµes executadas em determinada "parte" dos seus testes. SÃ£o bem Ãºteis caso vocÃª precise ajustar/resetar alguma configuraÃ§Ã£o antes, depois ou a cada teste, vocÃª consegue utilizÃ¡-las para realizar esse trabalho.

Podemos utilizar as funÃ§Ãµes:
- `beforeAll`: para executar algo antes de todos os testes;
- `afterAll`: para executar algo apÃ³s todos os testes finalizarem;
- `beforeEach`: para executar algo antes de cada um dos testes;
- `afterEach`: para executar algo apÃ³s cada um dos testes executarem.

Para utilizar essas funÃ§Ãµes, basta executarmos elas antes dos nossos cÃ³digos, algo como:

```js
import calculadora from './calculadora';

describe('Calculadora', () => {
  beforeAll(() => {
    // executa algum trecho de cÃ³digo
    calculadora.limpa();
  });

  it('Soma', () => {
    // atual (a ser testado)
    const atual = calculadora.soma(1, 1);
    // resultado esperado
    const resultado = 2;

    // asserÃ§Ã£o feita
    expect(atual).toEqual(esperado);
  });
});
```

A [documentaÃ§Ã£o](https://jestjs.io/docs/pt-BR/setup-teardown#repetindo-a-configura%C3%A7%C3%A3o-para-v%C3%A1rios-testes) do `Jest` tem uns exemplos bem bacanas se quiser dar uma lida.

### Arquivos
Por fim, apenas um detalhe que vale ser comentado, Ã© comum que alguns arquivos de teste sejam escritos dentro de um diretÃ³rio como `__test__` ou entÃ£o com o sufixo `.test` ou `.spec` (que quer dizer especificaÃ§Ã£o).

---

### E vocÃª, jÃ¡ trabalhou com testes? ğŸ§ª

Conhecia essas estruturas e jÃ¡ teve experiÃªncias com testes? Tem alguma ferramenta favorita que gosta de utilizar e quer comentar?

Espero que tenha curtido e que essas estruturas possam ajudar vocÃª a entender e organizar melhor seus testes.
