---
path: /draft/fundamentando-mocks-em-javascript

title: Fundamentando Mocks em JavaScript
subtitle: Como utilizar essa abordagem de forma consciente e evitar retrabalho, preocupa√ß√µes e dores de cabe√ßa nos seus testes
date: 2020-06-01
tags:
  - dev
  - tests

banner:
  author: J L
  href: https://unsplash.com/photos/kRaGJ42jfHI
  image: ./images/2020-06-01.fundamentando-mocks-em-javascript/banner.jpg
---

Parte importante de cria√ß√£o de [confian√ßa com o software que voc√™ escreve](https://gabrieluizramos.com.br/voce-confia-em-si/) √© a consci√™ncia e a fundamenta√ß√£o sobre como utilizar corretamente alguma estrutura de *mocks* no seu c√≥digo.

Um *mock* nada mais √© do que a substitui√ß√£o de um determinado trecho de c√≥digo por algo necess√°rio ao seu teste.

Vamos imaginar o seguinte cen√°rio:

> Voc√™ est√° desenvolvendo um e-commerce e, na tela de pagamento, ao clicar no bot√£o "finalizar compra" a sua compra √© efetuada e voc√™ recebe uma confirma√ß√£o em uma modal com uma mensagem de sucesso

Muito provavelmente voc√™ n√£o vai querer ficar simulando uma compra real a todo momento que executar seus testes unit√°rios. Se voc√™ fosse realizar algo dessa forma, teriam algumas vari√°veis que s√£o meio complicadas de serem previstas (conex√£o com internet, estabilidade e velocidade da conex√£o, tempo de resposta da API consumida) que poderiam impactar seus testes e que n√£o necessariamente entregariam algum valor pra voc√™ ou para seu teste. Sem contar que existem outros tipos de teste que podem assegurar esse cen√°rio.

√â justamente nesse cen√°rio que os *mocks* caem como uma luva. Nesse exemplo voc√™ consegue substituir esses trechos de c√≥digo respons√°veis por retornar o sucesso ou falha da requisi√ß√£o de sua API (ou qualquer necessidade externa e ass√≠ncrona) por um outro trecho espec√≠fico. Assim consegue de fato trabalhar e moldar as asser√ß√µes do seu teste com o que voc√™ espera em cada um dos casos de teste.

---

**Vale avisar que**: utilizarei *mock* como um termo geral para facilitar a comunica√ß√£o. Mesmo que existam outras nomenclaturas (como *fake* para dados, *spies* para verifica√ß√£o de fun√ß√µes e *stubs* para sobrescrever comportamento), √© bem comum que chamemos tudo de *mock* no dia-a-dia.

Lembrando que os exemplos citados aqui levam em considera√ß√£o a utiliza√ß√£o do [Jest](https://jestjs.io) como ferramenta de teste, mas os conceitos podem ser reaproveitados para o framework que voc√™ estiver usando.

---

### Antes de tudo, tenha em mente a unidade que voc√™ quer testar
Por desespero de fazer seus testes passarem √© muito comum "sair *mockando* tudo", mas isso pode ser muito pior do que voc√™ imagina.
Voc√™ deve utilizar estruturas de *mock* quando sua unidade (fun√ß√£o ou trecho de c√≥digo) possui depend√™ncia de algo que n√£o est√° no escopo do seu teste.

Voltando ao cen√°rio que mencionamos: o respons√°vel por disparar a real requisi√ß√£o para finalizar a compra √© o navegador ou dispositivo que est√° sendo utilizado.

Portanto, qualquer a√ß√£o que envolva algo que n√£o seja espec√≠fico do bot√£o "finalizar compra" √© um poss√≠vel candidato a receber um *mock* durante o teste desse exemplo que imaginamos.

### Criando *mocks*
Existem duas formas principais de escrever um *mock* no Jest: criando um *mock* no teste que estiver sendo executado ou utilizando criando uma pasta `__mock__` ao lado do arquivo que voc√™ estiver testando.

Focaremos na primeira op√ß√£o (de criar os *mocks* em nossos testes) que √© o mais importante para o momento. O que muda para o segundo caso √© apenas a estrutura de pasta.

No entanto, se quiser, voc√™ pode [ler a documenta√ß√£o](https://jestjs.io/docs/pt-BR/manual-mocks) tamb√©m.

### Tipos de *mock*
Vamos dividir nossos *mocks* nas seguintes categorias:
- dados;
- fun√ß√µes.

---

#### Dados
Provavelmente o cen√°rio mais simples de *mock* que existe, mas muito fundamental.

Vamos imaginar que n√≥s temos uma fun√ß√£o que recebe uma lista de personagens e um nome a ser filtrado.

Algo como:

```js
const filterCharacter = (characters, name) => {
  return characters.filter(char => char && char.name.includes(name));
}
```

Para conseguirmos testar essa fun√ß√£o, precisaremos utilizar uma lista de personagens (um *mock* no nosso teste) e algum par√¢metro de nome.

Escrevendo nosso *mock*, para esse teste, podemos ter algo como:

```js
const mockCharacters = [
  { name: 'anakin skywalker', nickname: 'darth vader' },
  { name: 'leia organa' },
  { name: 'luke skywalker' },
  { name: 'r2-d2' },
  { name: 'c3po' },
];
```

E podemos escrever um teste para verificar todos os personagens com sobrenome `skywalker`, por exemplo:

```js
import { filterCharacter } from './filter-character';

const mockCharacters = [
  { name: 'anakin skywalker', nickname: 'darth vader' },
  { name: 'leia organa' },
  { name: 'luke skywalker' },
  { name: 'r2-d2' },
  { name: 'c3po' },
];

describe('filterCharacter', () => {
  it('filtra uma lista de personagens por um determinado nome', () => {
    const resultado = filterCharacter(mockCharacters, 'skywalker');
    const esperado = 2;

    expect(resultado.length).toEqual(esperado);
  });
});
```

---

#### Fun√ß√µes
O Jest nos permite utilizar algumas [fun√ß√µes espec√≠ficas](https://jestjs.io/docs/pt-BR/jest-object#mock-functions) dependendo da necessidade do nosso teste e, para facilitar, vale a pena dividirmos esse t√≥pico em outros 3:

- fun√ß√µes;
- m√≥dulos;
- espi√µes.

##### Fun√ß√µes tradicionais
Vamos imaginar que nossa fun√ß√£o de filtrar personagens, recebe um terceiro par√¢metro. Esse novo par√¢metro √© uma fun√ß√£o que verifica se o personagem est√° vivo, baseado em um campo `alive`.

Nossa fun√ß√£o ser√° algo como:
```js
const filterCharacter = (characters, name, isAlive) => {
  return characters.filter(char => char && char.name.includes(name) && isAlive(char));
}
```

Essa fun√ß√£o n√£o est√° mais no escopo do nosso teste unit√°rio ent√£o podemos fazer um *mock* dela.

Para realizar o *mock* de uma fun√ß√£o, utilizamos o seguinte m√©todo do Jest:

```js
const mock = jest.fn();
```

O trecho `jest.fn()` retorna uma fun√ß√£o de *mock* para ser utilizada.

Caso voc√™ precise simular o comportamento dessa fun√ß√£o com algum resultado pr√©-definido, voc√™ pode passar uma implementa√ß√£o de uma fun√ß√£o como par√¢metro ou utilizar alguns outros m√©todos e inclusive receber qualquer par√¢metro.

Vamos imaginar que nossa fun√ß√£o sempre retorna `true`, por exemplo.

```js
const mockFn = jest.fn(() => true);
// ou utilizando .mockImplementation passando uma nova implementa√ß√£o
const mockFn = jest.fn().mockImplementation(() => true);
// ou utilizando .mockReturnedValue passando o valor de retorno diretamente
const mockFn = jest.fn().mockReturnedValue(true);
```

A lista completa dos m√©todos (vamos ver alguns a seguir) est√° [na documenta√ß√£o](https://jestjs.io/docs/pt-BR/mock-function-api#m%C3%A9todos).

Dessa maneira, conseguimos verificar se a fun√ß√£o `isAlive` foi chamada ou n√£o corretamente com as asser√ß√µes:

```js
// verifica se a fun√ß√£o foi chamada
expect(mockFn).toHaveBeenCalled();
// verifica quantas vezes a fun√ß√£o foi chamada (exemplo: 2)
expect(mockFn).toHaveBeenCalledTimes(2);
// verifica que a fun√ß√£o n√£o foi chamada
expect(mockFn).not.toHaveBeenCalledT();
// verifica que a fun√ß√£o n√£o foi chamada com algum par√¢metro (exemplo: 'false')
expect(mockFn).toHaveBeenCalledWith(false);
```

Vamos ao nosso teste:

```js
import { filterCharacter } from './filter-character';

// mock atualizado com os valores de "alive"
const mockCharacters = [
  { name: 'anakin skywalker', nickname: 'darth vader', alive: true },
  { name: 'leia organa', alive: false },
  { name: 'luke skywalker', alive: false },
  { name: 'r2-d2', alive: true },
  { name: 'c3po', alive: true },
];

describe('filterCharacter', () => {
  it('filtra uma lista de personagens por um determinado nome e verifica se o personagem est√° vivo', () => {
    const mockIsAlive = jest.fn(() => true)
    const resultado = filterCharacter(mockCharacters, 'skywalker', mockIsAlive);
    const esperado = 2;

    expect(resultado.length).toEqual(esperado);


    // como a fun√ß√£o isAlive √© executada quando o personagem
    // possui o nome passado como par√¢metro
    // podemos verificar se foi executada a mesma quantidade de vezes
    // que nosso resultado
    expect(mockIsAlive).toHaveBeenCalledTimes(resultado.length)
  });
});
```

Se quiser fazer um exerc√≠cio, crie um novo caso de teste onde o `mock` da fun√ß√£o `isAlive` retornar `false`. ‚úèÔ∏è

##### M√≥dulos
Vamos imaginar que agora a fun√ß√£o `isAlive` n√£o √© mais recebida como par√¢metro, mas √© uma depend√™ncia externa (m√≥dulo) da fun√ß√£o `filterCharacter`.
Ou seja, agora temos algo como:

```js
import { isAlive } from './is-alive';

const filterCharacter = (characters, name) => {
  return characters.filter(char => char && char.name.includes(name) && isAlive(char));
}
```

Para conseguir cobrir esse cen√°rio, utilizaremos a fun√ß√£o `jest.mock`. Essa fun√ß√£o, recebe como par√¢metro o caminho do m√≥dulo que ser√° sobrescrito com o *mock* (no nosso caso `is-alive`) e pode receber como segundo par√¢metro (opcionalmente) uma fun√ß√£o que pode retornar manualmente os valores que o m√≥dulo exporta. Caso esse segundo par√¢metro n√£o seja passado, por padr√£o, o Jest far√° um *automocking* das fun√ß√µes e far√° *mock* de todos os valores exportados.

Ou seja, para realizar o *mock* desse m√≥dulo, agora podemos seguir da seguinte maneira:

```js
jest.mock('./is-alive');
// ou
jest.mock('./is-alive', () => {
  return {
    isAlive: jest.fn();
  }
});
```

A diferen√ßa da primeira pra segunda utiliza√ß√£o √© que a segunda nos permite customizar os valores exportados pelo m√≥dulo, caso precisemos. Caso voc√™ opte por utilizar a primeira, todos as fun√ß√µes exportadas pelo m√≥dulo j√° ser√£o sobrescritas por uma fun√ß√£o de *mock* igual ao retorno do `jest.fn` por padr√£o.

Com isso, podemos manter nosso teste exatamente igual! A √∫nica diferen√ßa √© que n√£o precisaremos mais passar essa fun√ß√£o como par√¢metro e agora, ap√≥s realizar o *mock* de `is-alive`, iremos importar essa fun√ß√£o para verificar se ela foi de fato executada.

```js
import { filterCharacter } from './filter-character';
// importamos o modulo
import { isAlive } from './is-alive';

jest.mock('./is-alive', () => ({ isAlive: jest.fn(() => true) }));

const mockCharacters = [
  { name: 'anakin skywalker', nickname: 'darth vader', alive: true },
  { name: 'leia organa', alive: false },
  { name: 'luke skywalker', alive: false },
  { name: 'r2-d2', alive: true },
  { name: 'c3po', alive: true },
];

describe('filterCharacter', () => {
  it('filtra uma lista de personagens por um determinado nome e verifica se o personagem est√° vivo', () => {
    const resultado = filterCharacter(mockCharacters, 'skywalker');
    const esperado = 2;

    expect(resultado.length).toEqual(esperado);

    // modificamos para usar o import
    expect(isAlive).toHaveBeenCalledTimes(mockCharacters.length)
  });
});
```

##### Espi√µes
At√© agora s√≥ vimos como realizar *mock* das fun√ß√µes mas, se quis√©ssemos manter a execu√ß√£o de alguma fun√ß√£o, sem sobrescrever seu comportamento?

Vamos imaginar que, agora, teremos um novo m√≥dulo chamado `logger`. Esse m√≥dulo exporta uma fun√ß√£o `log` que ser√° executado junto com o filtro. Da seguinte maneira:

```js
import { isAlive } from './is-alive';
import { log } from './logger';

const filterCharacter = (characters, name) => {
  return characters.filter(char => {
    log(char);
    return char && char.name.includes(name) && isAlive(char);
  });
}
```

N√£o precisamos implementar essa nova fun√ß√£o, mas vamos imaginar que agora vamos apenas verificar se ela foi chamada corretamente, sem precisar nos preocupar com a forma que ela √© implementada.

Para nos ajudar dessa vez, utilizaremos o m√©todo [`spyOn`](https://jestjs.io/docs/pt-BR/jest-object#jestspyonobject-methodname) do jest. Esse m√©todo recebe como par√¢metro o objeto a ser "espionado" e a fun√ß√£o a ser verificada, da seguinte maneira:

```js
// importamos tudo para que possamos verificar a fun√ß√£o `log`
import * as logger from './logger';

const spy = jest.spyOn(logger, 'log');
```

Dessa forma, seguimos nossos testes normalmente com o que j√° t√≠nhamos e validamos se nosso *mock* da fun√ß√£o `log` foi chamado corretamente.

```js
import { filterCharacter } from './filter-character';
import { isAlive } from './is-alive';
import * as logger from './logger';

jest.mock('./is-alive', () => ({ isAlive: jest.fn(() => true) }));

const mockCharacters = [
  { name: 'anakin skywalker', nickname: 'darth vader', alive: true },
  { name: 'leia organa', alive: false },
  { name: 'luke skywalker', alive: false },
  { name: 'r2-d2', alive: true },
  { name: 'c3po', alive: true },
];

describe('filterCharacter', () => {
  it('filtra uma lista de personagens por um determinado nome e verifica se o personagem est√° vivo', () => {
    const espiao = jest.spyOn(logger, 'log');
    const resultado = filterCharacter(mockCharacters, 'skywalker');
    const esperado = 2;

    expect(resultado.length).toEqual(esperado);

    expect(isAlive).toHaveBeenCalledTimes(resultado.length)

    // como a fun√ß√£o log √© executada sempre
    // que os personagens s√£o filtrado
    // podemos verificar se a quantidade de vezes
    // √© igual √† quantidade de personagens no mock
    expect(espiao).toHaveBeenCalledTimes(mockCharacters.length);
  });
});
```

---

### üö® N√£o esque√ßa de "limpar" seus *mocks* üö®
Se tem uma coisa mais importante do que saber como utilizar um *mock* de forma consciente √© saber limpar um *mock* ap√≥s seus testes. Com certeza isso vai poupar uma dor de cabe√ßa e evitar que voc√™ possa ter problemas futuros em outros testes que tentem acessar seus m√≥dulos.

Para fun√ß√µes de `spy`, basta executar o m√©todo `mockRestore`, da seguinte forma:
```js
const espiao = jest.spyOn(logger, 'log');

// ap√≥s o teste
espiao.mockRestore();
```

Para fun√ß√µes que manipulamos com `jest.fn()`, podemos utilizar outros m√©todos como:
```js
const mockFn = jest.fn();

// ap√≥s o teste

// limpa as execu√ß√µes
// mas mant√©m as implementa√ß√µes
mockFn.mockClear();

// limpa as execu√ß√µes
// e as implementa√ß√µes
mockFn.mockReset();

// limpa as execu√ß√µes
// e as implementa√ß√µes
// e tamb√©m faz com que a fun√ß√£o retorne ao seu valor original
// antes do mock
mockFn.mockRestore();
```

Muito provavelmente voc√™ vai querer automatizar essas limpezas em algum hook dos seus testes, como [vimos anteriormente](https://gabrieluizramos.com.br/anatomia-de-um-teste-em-javascript).

---

### J√° utilizava *mock* nos seus testes?
J√° teve experi√™ncia (ou at√© mesmo dores de cabe√ßa) com alguma estrutura de *mock*?

Espero que possa ter ajudado e que, de agora em diante, voc√™ possa utilizar essas ferramentas a favor dos testes que voc√™ estiver escrevendo!
